<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K·ª∑ y·∫øu c√πng Huy - Ho√†n thi·ªán 360 & Heart</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        #ui-layer {
            position: absolute; bottom: 40px; width: 100%;
            text-align: center; pointer-events: none; z-index: 100;
        }
        
        .status-badge {
            display: inline-block; padding: 12px 35px;
            background: rgba(255, 255, 255, 0.08); 
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px; color: #fff; font-weight: 600;
            backdrop-filter: blur(15px); transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            letter-spacing: 1px;
        }

        #video-container {
            position: absolute; top: 20px; left: 20px;
            width: 150px; height: 110px; border-radius: 12px;
            overflow: hidden; border: 1.5px solid rgba(255,255,255,0.3);
            z-index: 50; transform: scaleX(-1);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

    <div id="video-container">
        <video id="input_video"></video>
    </div>

    <div id="ui-layer">
        <div id="status" class="status-badge">ƒêang kh·ªüi t·∫°o camera...</div>
    </div>

    <div id="canvas-container"></div>

    <script>
        let scene, camera, renderer, textParticles, photoGroup;
        let state = 'TEXT'; 
        let rotationAngle = 0;
        let focusedPhotoIndex = -1; 
        
        const TEXT_STR = "K·ª∑ y·∫øu c√πng Huy";
        const PARTICLE_COUNT = 10000; // TƒÉng s·ªë l∆∞·ª£ng h·∫°t ƒë·ªÉ kh√¥ng b·ªã m·∫•t h√¨nh
        const PHOTO_COUNT = 6;
        const PHOTO_URLS = [
            'https://picsum.photos/800/600?sig=101',
            'https://picsum.photos/800/600?sig=102',
            'https://picsum.photos/800/600?sig=103',
            'https://picsum.photos/800/600?sig=104',
            'https://picsum.photos/800/600?sig=105',
            'https://picsum.photos/800/600?sig=106'
        ];

        init();
        setupMediaPipe();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createTextParticles();
            createPhotoGallery();

            scene.add(new THREE.AmbientLight(0xffffff, 2));
            animate();
        }

        function createTextParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            const heartPositions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);

            // V·∫Ω ch·ªØ l√™n Canvas ng·∫ßm ƒë·ªÉ l·∫•y t·ªça ƒë·ªô
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1600; canvas.height = 400;
            ctx.fillStyle = 'white';
            ctx.font = 'bold 140px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(TEXT_STR, 800, 220);

            const imgData = ctx.getImageData(0, 0, 1600, 400).data;
            const points = [];
            // Qu√©t pixel v·ªõi b∆∞·ªõc nh·∫£y nh·ªè ƒë·ªÉ l·∫•y to√†n b·ªô ch·ªØ
            for (let y = 0; y < 400; y += 2) {
                for (let x = 0; x < 1600; x += 2) {
                    if (imgData[(y * 1600 + x) * 4 + 3] > 150) {
                        points.push({ x: (x - 800) * 0.012, y: (200 - y) * 0.012 });
                    }
                }
            }

            // T·∫°o h√¨nh tr√°i tim 3D
            const heartPoints = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = Math.random() * Math.PI * 2;
                const r = 0.22;
                const hx = 16 * Math.pow(Math.sin(t), 3) * r;
                const hy = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * r;
                heartPoints.push({ x: hx, y: hy });
            }

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // ƒê·∫£m b·∫£o l·∫•y m·∫´u ƒë·ªÅu t·ª´ danh s√°ch ƒëi·ªÉm ch·ªØ
                const p = points[Math.floor((i / PARTICLE_COUNT) * points.length)];
                const hp = heartPoints[i];

                // V·ªã tr√≠ ban ƒë·∫ßu ng·∫´u nhi√™n
                positions[i*3] = (Math.random() - 0.5) * 20;
                positions[i*3+1] = (Math.random() - 0.5) * 10;
                positions[i*3+2] = (Math.random() - 0.5) * 10;

                // T·ªça ƒë·ªô m·ª•c ti√™u cho ch·ªØ
                targetPositions[i*3] = p.x;
                targetPositions[i*3+1] = p.y;
                targetPositions[i*3+2] = 0;

                // T·ªça ƒë·ªô m·ª•c ti√™u cho tr√°i tim
                heartPositions[i*3] = hp.x;
                heartPositions[i*3+1] = hp.y;
                heartPositions[i*3+2] = (Math.random() - 0.5) * 1.5;

                const color = new THREE.Color();
                color.setHSL(0.58 + Math.random() * 0.1, 0.8, 0.6); 
                colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('target', new THREE.BufferAttribute(targetPositions, 3));
            geometry.setAttribute('heart', new THREE.BufferAttribute(heartPositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            textParticles = new THREE.Points(geometry, new THREE.PointsMaterial({
                size: 0.03, vertexColors: true, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending
            }));
            scene.add(textParticles);
        }

        function createPhotoGallery() {
            photoGroup = new THREE.Group();
            const loader = new THREE.TextureLoader();
            for(let i=0; i<PHOTO_COUNT; i++) {
                const mat = new THREE.MeshStandardMaterial({ 
                    map: loader.load(PHOTO_URLS[i]), 
                    transparent: true, 
                    opacity: 0, 
                    side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(3.2, 2.4), mat);
                mesh.userData.angle = (i / PHOTO_COUNT) * Math.PI * 2;
                mesh.position.set(0, 0, -25);
                photoGroup.add(mesh);
            }
            scene.add(photoGroup);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const posAttr = textParticles.geometry.attributes.position;
            const targetAttr = textParticles.geometry.attributes.target;
            const heartAttr = textParticles.geometry.attributes.heart;

            if (state === 'TEXT') {
                textParticles.rotation.y = 0; 
                rotationAngle = 0;
                photoGroup.rotation.y = 0;
                focusedPhotoIndex = -1;
                
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    posAttr.array[i*3] += (targetAttr.array[i*3] - posAttr.array[i*3]) * 0.1;
                    posAttr.array[i*3+1] += (targetAttr.array[i*3+1] - posAttr.array[i*3+1]) * 0.1;
                    posAttr.array[i*3+2] += (targetAttr.array[i*3+2] - posAttr.array[i*3+2]) * 0.1;
                }
            } 
            else if (state === 'EXPLODE') {
                rotationAngle += 0.008;
                textParticles.rotation.y = rotationAngle;
                photoGroup.rotation.y = rotationAngle; 

                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const tx = targetAttr.array[i*3] * 3.5 + Math.sin(rotationAngle * 0.5 + i) * 1.5;
                    const ty = targetAttr.array[i*3+1] * 3.5 + Math.cos(rotationAngle * 0.5 + i) * 1.5;
                    const tz = Math.sin(rotationAngle + i) * 4;
                    posAttr.array[i*3] += (tx - posAttr.array[i*3]) * 0.04;
                    posAttr.array[i*3+1] += (ty - posAttr.array[i*3+1]) * 0.04;
                    posAttr.array[i*3+2] += (tz - posAttr.array[i*3+2]) * 0.04;
                }
            }
            else if (state === 'HEART') {
                rotationAngle += 0.005;
                textParticles.rotation.y = Math.sin(rotationAngle) * 0.4;
                
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    posAttr.array[i*3] += (heartAttr.array[i*3] * 1.8 - posAttr.array[i*3]) * 0.08;
                    posAttr.array[i*3+1] += (heartAttr.array[i*3+1] * 1.8 - posAttr.array[i*3+1]) * 0.08;
                    posAttr.array[i*3+2] += (heartAttr.array[i*3+2] - posAttr.array[i*3+2]) * 0.08;
                }
            }
            else if (state === 'PHOTO') {
                rotationAngle += 0.01;
                textParticles.rotation.y = rotationAngle * 0.4;
                
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const radius = 7 + Math.sin(i) * 2;
                    const tx = Math.cos(i + rotationAngle) * radius;
                    const ty = Math.sin(i * 0.5 + rotationAngle) * (radius * 0.6);
                    const tz = -5 + Math.cos(rotationAngle + i) * 3;

                    posAttr.array[i*3] += (tx - posAttr.array[i*3]) * 0.03;
                    posAttr.array[i*3+1] += (ty - posAttr.array[i*3+1]) * 0.03;
                    posAttr.array[i*3+2] += (tz - posAttr.array[i*3+2]) * 0.03;
                }
            }

            posAttr.needsUpdate = true;

            // Gallery
            photoGroup.children.forEach((mesh, i) => {
                if (state === 'PHOTO') {
                    if (i === focusedPhotoIndex) {
                        mesh.position.lerp(new THREE.Vector3(0, 0, 4.5), 0.1); 
                        mesh.scale.lerp(new THREE.Vector3(2.5, 1.8, 1), 0.1); 
                        mesh.material.opacity += (1 - mesh.material.opacity) * 0.1;
                        mesh.rotation.y = 0; 
                        mesh.renderOrder = 999;
                    } else {
                        const orbitX = Math.cos(mesh.userData.angle + rotationAngle) * 8;
                        const orbitY = Math.sin(mesh.userData.angle + rotationAngle) * 5;
                        mesh.position.lerp(new THREE.Vector3(orbitX, orbitY, -6), 0.08);
                        mesh.scale.lerp(new THREE.Vector3(0.8, 0.6, 1), 0.08);
                        mesh.material.opacity += (0.1 - mesh.material.opacity) * 0.1;
                        mesh.lookAt(camera.position);
                        mesh.renderOrder = 0;
                    }
                } else if (state === 'EXPLODE') {
                    const orbitX = Math.cos(mesh.userData.angle) * 6;
                    const orbitY = Math.sin(mesh.userData.angle) * 4;
                    mesh.position.lerp(new THREE.Vector3(orbitX, orbitY, -2), 0.05);
                    mesh.scale.lerp(new THREE.Vector3(1.2, 0.9, 1), 0.05);
                    mesh.material.opacity += (0.8 - mesh.material.opacity) * 0.05;
                } else {
                    mesh.position.lerp(new THREE.Vector3(0, 0, -25), 0.1);
                    mesh.scale.lerp(new THREE.Vector3(0.5, 0.5, 1), 0.1);
                    mesh.material.opacity += (0 - mesh.material.opacity) * 0.1;
                }
            });

            renderer.render(scene, camera);
        }

        function setupMediaPipe() {
            const video = document.getElementById('input_video');
            const statusDiv = document.getElementById('status');
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });

            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    if (results.multiHandLandmarks.length === 2) {
                        const h1 = results.multiHandLandmarks[0];
                        const h2 = results.multiHandLandmarks[1];
                        const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                        const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                        
                        if (distThumb < 0.12 && distIndex < 0.12) {
                            state = 'HEART';
                            statusDiv.innerText = "‚ù§Ô∏è TR√ÅI TIM K·ª∂ NI·ªÜM ‚ù§Ô∏è";
                            statusDiv.style.color = "#ff3366";
                            return;
                        }
                    }

                    const lm = results.multiHandLandmarks[0];
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    let openDist = 0; 
                    [8,12,16,20].forEach(id => openDist += Math.hypot(lm[id].x-lm[0].x, lm[id].y-lm[0].y));
                    const openFactor = openDist / 4;

                    if (openFactor < 0.22) {
                        state = 'TEXT';
                        statusDiv.innerText = "‚úä N·∫Øm tay: T√™n ƒê·ª©ng Y√™n";
                        statusDiv.style.color = "#fff";
                    } else if (pinchDist < 0.05) {
                        if (state !== 'PHOTO') focusedPhotoIndex = Math.floor(Math.random() * PHOTO_COUNT);
                        state = 'PHOTO';
                        statusDiv.innerText = "üëå Ch·∫°m ng√≥n: Xem ·∫¢nh Zoom";
                        statusDiv.style.color = "#00ffff";
                    } else {
                        state = 'EXPLODE';
                        statusDiv.innerText = "üñê X√≤e tay: Kh√¥ng Gian 360¬∞";
                        statusDiv.style.color = "#00ff88";
                    }
                } else {
                    state = 'TEXT';
                    statusDiv.innerText = "Gi∆° tay t∆∞∆°ng t√°c n√†o!";
                }
            });

            new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 640, height: 480 }).start();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
