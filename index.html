<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K·ª∑ y·∫øu c√πng Huy </title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        #ui-layer {
            position: absolute; bottom: 40px; width: 100%;
            text-align: center; pointer-events: none; z-index: 100;
        }
        
        .status-badge {
            display: inline-block; padding: 12px 35px;
            background: rgba(255, 255, 255, 0.08); 
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px; color: #fff; font-weight: 600;
            backdrop-filter: blur(15px); transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            letter-spacing: 1px; min-width: 320px;
        }

        #video-container {
            position: absolute; top: 20px; left: 20px;
            width: 150px; height: 112px; border-radius: 12px;
            overflow: hidden; border: 2px solid rgba(0, 255, 136, 0.5);
            z-index: 50; transform: scaleX(-1);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
            background: #111;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

    <div id="video-container">
        <video id="input_video" playsinline></video>
    </div>

    <div id="ui-layer">
        <div id="status" class="status-badge">ƒêang kh·ªüi ƒë·ªông camera...</div>
    </div>

    <div id="canvas-container"></div>

    <script>
        let scene, camera, renderer, textParticles, photoGroup;
        let state = 'TEXT'; 
        let rotationAngle = 0;
        let focusedPhotoIndex = -1; 
        
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;

        // Countdown logic
        let countdownValue = 3;
        let countdownTimer = null;
        
        const TEXT_STR_1 = "K·ª∑ y·∫øu c√πng Huy";
        const TEXT_STR_INVITE = "v√†o 10h30 ƒë·∫øn ch·ª•p c√πng Huy nh√©";
        const PARTICLE_COUNT = 10000; 
        const PHOTO_COUNT = 8;
        const PHOTO_URLS = [
            '1.mov', '2.mov',
            'https://picsum.photos/800/600?sig=103', 'https://picsum.photos/800/600?sig=104',
            'https://picsum.photos/800/600?sig=105', 'https://picsum.photos/800/600?sig=106',
            'https://picsum.photos/800/600?sig=107', 'https://picsum.photos/800/600?sig=108'
        ];

        init();
        setupMediaPipe();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createTextParticles();
            createPhotoGallery();

            scene.add(new THREE.AmbientLight(0xffffff, 2.5));
            animate();
        }

        function getPointsFromText(text, fontSize, width, height) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = width; canvas.height = height;
            ctx.fillStyle = 'white';
            ctx.font = `bold ${fontSize}px "Segoe UI", sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(text, width/2, height/2 + fontSize/3);

            const imgData = ctx.getImageData(0, 0, width, height).data;
            const points = [];
            const step = 2;
            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    if (imgData[(y * width + x) * 4 + 3] > 128) {
                        points.push({ 
                            x: (x - width/2) * (14/width), 
                            y: (height/2 - y) * (14/width) 
                        });
                    }
                }
            }
            return points;
        }

        function createTextParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            
            const target1 = new Float32Array(PARTICLE_COUNT * 3);
            const targetInvite = new Float32Array(PARTICLE_COUNT * 3);
            const target3 = new Float32Array(PARTICLE_COUNT * 3);
            const target2 = new Float32Array(PARTICLE_COUNT * 3);
            const target1Num = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);

            const p1 = getPointsFromText(TEXT_STR_1, 140, 1600, 400);
            const pInvite = getPointsFromText(TEXT_STR_INVITE, 80, 1600, 400);
            const p3 = getPointsFromText("3", 300, 800, 800);
            const p2Num = getPointsFromText("2", 300, 800, 800);
            const p1Num = getPointsFromText("1", 300, 800, 800);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const fill = (arr, pts) => {
                    const pt = pts[Math.floor((i / PARTICLE_COUNT) * pts.length)];
                    arr[i*3] = pt.x; arr[i*3+1] = pt.y; arr[i*3+2] = 0;
                };

                fill(target1, p1);
                fill(targetInvite, pInvite);
                fill(target3, p3);
                fill(target2, p2Num);
                fill(target1Num, p1Num);

                positions[i*3] = (Math.random() - 0.5) * 50;
                positions[i*3+1] = (Math.random() - 0.5) * 50;
                positions[i*3+2] = (Math.random() - 0.5) * 50;

                const color = new THREE.Color();
                color.setHSL(0.55 + Math.random() * 0.1, 0.9, 0.6); 
                colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('target1', new THREE.BufferAttribute(target1, 3));
            geometry.setAttribute('targetInvite', new THREE.BufferAttribute(targetInvite, 3));
            geometry.setAttribute('target3', new THREE.BufferAttribute(target3, 3));
            geometry.setAttribute('target2', new THREE.BufferAttribute(target2, 3));
            geometry.setAttribute('target1Num', new THREE.BufferAttribute(target1Num, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            textParticles = new THREE.Points(geometry, new THREE.PointsMaterial({
                size: 0.05, vertexColors: true, transparent: true, opacity: 0.85, blending: THREE.AdditiveBlending
            }));
            scene.add(textParticles);
        }

        function createPhotoGallery() {
            photoGroup = new THREE.Group();
            const loader = new THREE.TextureLoader();
            for(let i=0; i<PHOTO_COUNT; i++) {
                const mat = new THREE.MeshStandardMaterial({ 
                    map: loader.load(PHOTO_URLS[i]), 
                    transparent: true, opacity: 0, side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 2.6), mat);
                mesh.userData.angle = (i / PHOTO_COUNT) * Math.PI * 2;
                mesh.userData.depthOffset = Math.random() * 10 - 5;
                mesh.position.set(0, 0, -50);
                photoGroup.add(mesh);
            }
            scene.add(photoGroup);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const posAttr = textParticles.geometry.attributes.position;
            const attrs = textParticles.geometry.attributes;

            currentRotationX += (targetRotationX - currentRotationX) * 0.08;
            currentRotationY += (targetRotationY - currentRotationY) * 0.08;

            let currentTarget = attrs.target1;

            if (state === 'TEXT') currentTarget = attrs.target1;
            else if (state === 'INVITE') currentTarget = attrs.targetInvite;
            else if (state === 'COUNTDOWN') {
                if (countdownValue === 3) currentTarget = attrs.target3;
                else if (countdownValue === 2) currentTarget = attrs.target2;
                else if (countdownValue === 1) currentTarget = attrs.target1Num;
            }

            if (state === 'EXPLODE' || state === 'PHOTO') {
                rotationAngle += 0.005;
                textParticles.rotation.set(0, rotationAngle, 0);
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const radius = (state === 'PHOTO' ? 20 : 25);
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    const tx = radius * Math.sin(phi) * Math.cos(theta + rotationAngle);
                    const ty = radius * Math.sin(phi) * Math.sin(theta + (state === 'PHOTO' ? rotationAngle * 0.2 : rotationAngle));
                    const tz = radius * Math.cos(phi) - 15;
                    posAttr.array[i*3] += (tx - posAttr.array[i*3]) * 0.05;
                    posAttr.array[i*3+1] += (ty - posAttr.array[i*3+1]) * 0.05;
                    posAttr.array[i*3+2] += (tz - posAttr.array[i*3+2]) * 0.05;
                }
            } else {
                textParticles.rotation.set(0, 0, 0);
                const speed = (state === 'COUNTDOWN') ? 0.2 : 0.1;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    posAttr.array[i*3] += (currentTarget.array[i*3] - posAttr.array[i*3]) * speed;
                    posAttr.array[i*3+1] += (currentTarget.array[i*3+1] - posAttr.array[i*3+1]) * speed;
                    posAttr.array[i*3+2] += (currentTarget.array[i*3+2] - posAttr.array[i*3+2]) * speed;
                }
            }

            posAttr.needsUpdate = true;

            photoGroup.children.forEach((mesh, i) => {
                if (state === 'PHOTO' && i === focusedPhotoIndex) {
                    mesh.position.lerp(new THREE.Vector3(0, 0.2, 4.8), 0.15); 
                    mesh.scale.lerp(new THREE.Vector3(1.8, 1.35, 1), 0.15);
                    mesh.material.opacity += (1 - mesh.material.opacity) * 0.15;
                    mesh.rotation.set(0, 0, 0);
                } else if (state === 'EXPLODE') {
                    const orbitRadius = 25 + mesh.userData.depthOffset;
                    const ox = Math.cos(mesh.userData.angle + rotationAngle) * orbitRadius;
                    const oz = Math.sin(mesh.userData.angle + rotationAngle) * orbitRadius;
                    mesh.position.lerp(new THREE.Vector3(ox, Math.sin(i)*5, oz - 15), 0.05);
                    mesh.material.opacity += (0.8 - mesh.material.opacity) * 0.05;
                    mesh.lookAt(camera.position);
                } else {
                    mesh.position.lerp(new THREE.Vector3(0, 0, -60), 0.1);
                    mesh.material.opacity += (0 - mesh.material.opacity) * 0.1;
                }
            });

            renderer.render(scene, camera);
        }

        function resetToDefault() {
            if (countdownTimer) {
                clearInterval(countdownTimer);
                countdownTimer = null;
            }
            state = 'TEXT';
            document.getElementById('status').innerText = "K·ª∑ y·∫øu c√πng Huy";
        }

        function startCountdown() {
            if (state === 'COUNTDOWN' || state === 'INVITE') return;
            state = 'COUNTDOWN';
            countdownValue = 3;
            if (countdownTimer) clearInterval(countdownTimer);
            
            countdownTimer = setInterval(() => {
                countdownValue--;
                if (countdownValue <= 0) {
                    clearInterval(countdownTimer);
                    countdownTimer = null;
                    state = 'INVITE';
                    document.getElementById('status').innerText = "üì∏ CH·ª§P TH√îI HUY ∆†I!";
                }
            }, 1000);
        }

        async function setupMediaPipe() {
            const video = document.getElementById('input_video');
            const statusDiv = document.getElementById('status');
            
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    
                    const isIndexOpen = lm[8].y < lm[6].y;
                    const isMiddleOpen = lm[12].y < lm[10].y;
                    const isRingOpen = lm[16].y < lm[14].y;
                    const isPinkyOpen = lm[20].y < lm[18].y;
                    const isThumbOpen = Math.hypot(lm[4].x - lm[9].x, lm[4].y - lm[9].y) > 0.12;

                    // ƒê·∫øm s·ªë ng√≥n tay m·ªü (kh√¥ng t√≠nh ng√≥n c√°i cho ch√≠nh x√°c)
                    let fingerCount = 0;
                    if (isIndexOpen) fingerCount++;
                    if (isMiddleOpen) fingerCount++;
                    if (isRingOpen) fingerCount++;
                    if (isPinkyOpen) fingerCount++;

                    // 1. CH·ª®C NƒÇNG 3 NG√ìN (CH·ªà TR·ªé, GI·ªÆA, √ÅP √öT M·ªû) -> ƒê·∫æM NG∆Ø·ª¢C
                    if (isIndexOpen && isMiddleOpen && isRingOpen && !isPinkyOpen) {
                        startCountdown();
                        if (state === 'COUNTDOWN') statusDiv.innerText = `üî• ƒêang ƒë·∫øm ng∆∞·ª£c: ${countdownValue}...`;
                        return;
                    }

                    // 2. CH·ª®C NƒÇNG CH·ª§M 2 NG√ìN (C√°i + Tr·ªè ch·ª•m, c√°c ng√≥n kh√°c kh√©p) -> PH√ìNG TO ·∫¢NH
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    if (pinchDist < 0.045 && !isMiddleOpen && !isRingOpen) {
                        if (state !== 'PHOTO') focusedPhotoIndex = Math.floor(Math.random() * PHOTO_COUNT);
                        state = 'PHOTO';
                        statusDiv.innerText = "üëå ƒêang xem ·∫£nh ch√≠nh di·ªán";
                        return;
                    }

                    // 3. X√íE C·∫¢ B√ÄN TAY (4 ho·∫∑c 5 ng√≥n m·ªü) -> M·ªû KH√îNG GIAN 360
                    if (fingerCount >= 4 || (fingerCount >= 3 && isPinkyOpen)) {
                        state = 'EXPLODE';
                        statusDiv.innerText = "üñê Kh√¥ng gian 360 ƒë·ªô";
                        if (countdownTimer) resetToDefault();
                        return;
                    }

                    // 4. N·∫ÆM TAY -> HI·ªÜN T√äN
                    if (fingerCount <= 1) {
                        state = 'TEXT';
                        statusDiv.innerText = "‚úä N·∫Øm tay: Hi·ªán t√™n";
                        if (countdownTimer) resetToDefault();
                        return;
                    }

                } else {
                    resetToDefault();
                    statusDiv.innerText = "Gi∆° tay l√™n n√†o!";
                }
            });

            const cam = new Camera(video, { onFrame: async () => await hands.send({image: video}), width: 640, height: 480 });
            cam.start();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
