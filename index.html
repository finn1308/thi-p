<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K·ª∑ y·∫øu c√πng Huy </title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        #ui-layer {
            position: absolute; bottom: 40px; width: 100%;
            text-align: center; pointer-events: none; z-index: 100;
        }
        
        .status-badge {
            display: inline-block; padding: 12px 35px;
            background: rgba(255, 255, 255, 0.08); 
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px; color: #fff; font-weight: 600;
            backdrop-filter: blur(15px); transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            letter-spacing: 1px; min-width: 300px;
        }

        #video-container {
            position: absolute; top: 20px; left: 20px;
            width: 150px; height: 112px; border-radius: 12px;
            overflow: hidden; border: 2px solid rgba(0, 255, 136, 0.5);
            z-index: 50; transform: scaleX(-1);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
            background: #111;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

    <div id="video-container">
        <video id="input_video" playsinline></video>
    </div>

    <div id="ui-layer">
        <div id="status" class="status-badge">ƒêang qu√©t kh√¥ng gian...</div>
    </div>

    <div id="canvas-container"></div>

    <script>
        let scene, camera, renderer, textParticles, photoGroup;
        let state = 'TEXT'; 
        let rotationAngle = 0;
        let focusedPhotoIndex = -1; 
        
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;

        let smoothedPinchDist = 1;
        let smoothedOpenFactor = 0;
        
        const TEXT_STR = "K·ª∑ y·∫øu c√πng Huy";
        const PARTICLE_COUNT = 10000; 
        const PHOTO_COUNT = 6;
        const PHOTO_URLS = [
            'https://picsum.photos/800/600?sig=101',
            'https://picsum.photos/800/600?sig=102',
            'https://picsum.photos/800/600?sig=103',
            'https://picsum.photos/800/600?sig=104',
            'https://picsum.photos/800/600?sig=105',
            'https://picsum.photos/800/600?sig=106'
        ];

        init();
        setupMediaPipe();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createTextParticles();
            createPhotoGallery();

            scene.add(new THREE.AmbientLight(0xffffff, 2.5));
            animate();
        }

        function createTextParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            const heartPositions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1600; canvas.height = 400;
            ctx.fillStyle = 'white';
            ctx.font = 'bold 140px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(TEXT_STR, 800, 220);

            const imgData = ctx.getImageData(0, 0, 1600, 400).data;
            const points = [];
            for (let y = 0; y < 400; y += 2) {
                for (let x = 0; x < 1600; x += 2) {
                    if (imgData[(y * 1600 + x) * 4 + 3] > 120) {
                        points.push({ x: (x - 800) * 0.012, y: (200 - y) * 0.012 });
                    }
                }
            }

            const heartPoints = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = Math.random() * Math.PI * 2;
                const r = 0.22;
                const hx = 16 * Math.pow(Math.sin(t), 3) * r;
                const hy = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * r;
                heartPoints.push({ x: hx, y: hy });
            }

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = points[Math.floor((i / PARTICLE_COUNT) * points.length)];
                const hp = heartPoints[i];

                positions[i*3] = (Math.random() - 0.5) * 30;
                positions[i*3+1] = (Math.random() - 0.5) * 20;
                positions[i*3+2] = (Math.random() - 0.5) * 20;

                targetPositions[i*3] = p.x;
                targetPositions[i*3+1] = p.y;
                targetPositions[i*3+2] = 0;

                heartPositions[i*3] = hp.x;
                heartPositions[i*3+1] = hp.y;
                heartPositions[i*3+2] = (Math.random() - 0.5) * 2;

                const color = new THREE.Color();
                color.setHSL(0.55 + Math.random() * 0.1, 0.9, 0.6); 
                colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('target', new THREE.BufferAttribute(targetPositions, 3));
            geometry.setAttribute('heart', new THREE.BufferAttribute(heartPositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            textParticles = new THREE.Points(geometry, new THREE.PointsMaterial({
                size: 0.035, vertexColors: true, transparent: true, opacity: 0.85, blending: THREE.AdditiveBlending
            }));
            scene.add(textParticles);
        }

        function createPhotoGallery() {
            photoGroup = new THREE.Group();
            const loader = new THREE.TextureLoader();
            for(let i=0; i<PHOTO_COUNT; i++) {
                const mat = new THREE.MeshStandardMaterial({ 
                    map: loader.load(PHOTO_URLS[i]), 
                    transparent: true, 
                    opacity: 0, 
                    side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 2.6), mat);
                mesh.userData.angle = (i / PHOTO_COUNT) * Math.PI * 2;
                mesh.position.set(0, 0, -30);
                photoGroup.add(mesh);
            }
            scene.add(photoGroup);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const posAttr = textParticles.geometry.attributes.position;
            const targetAttr = textParticles.geometry.attributes.target;
            const heartAttr = textParticles.geometry.attributes.heart;

            currentRotationX += (targetRotationX - currentRotationX) * 0.08;
            currentRotationY += (targetRotationY - currentRotationY) * 0.08;

            if (state === 'TEXT') {
                textParticles.rotation.set(0, 0, 0);
                photoGroup.rotation.set(0, 0, 0);
                rotationAngle = 0;
                focusedPhotoIndex = -1;
                
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    posAttr.array[i*3] += (targetAttr.array[i*3] - posAttr.array[i*3]) * 0.1;
                    posAttr.array[i*3+1] += (targetAttr.array[i*3+1] - posAttr.array[i*3+1]) * 0.1;
                    posAttr.array[i*3+2] += (targetAttr.array[i*3+2] - posAttr.array[i*3+2]) * 0.1;
                }
            } 
            else if (state === 'EXPLODE') {
                rotationAngle += 0.006;
                // Khi bung l·ª•a, ·∫£nh v√† h·∫°t xoay theo tay
                textParticles.rotation.set(currentRotationX, rotationAngle + currentRotationY, 0);
                photoGroup.rotation.set(currentRotationX, rotationAngle + currentRotationY, 0);

                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const tx = targetAttr.array[i*3] * 4 + Math.sin(rotationAngle + i) * 2;
                    const ty = targetAttr.array[i*3+1] * 4 + Math.cos(rotationAngle + i) * 2;
                    const tz = Math.sin(rotationAngle * 0.5 + i) * 5;
                    posAttr.array[i*3] += (tx - posAttr.array[i*3]) * 0.04;
                    posAttr.array[i*3+1] += (ty - posAttr.array[i*3+1]) * 0.04;
                    posAttr.array[i*3+2] += (tz - posAttr.array[i*3+2]) * 0.04;
                }
            }
            else if (state === 'HEART') {
                rotationAngle += 0.01;
                textParticles.rotation.set(0, Math.sin(rotationAngle * 0.5) * 0.3, 0);
                
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    posAttr.array[i*3] += (heartAttr.array[i*3] * 2 - posAttr.array[i*3]) * 0.1;
                    posAttr.array[i*3+1] += (heartAttr.array[i*3+1] * 2 - posAttr.array[i*3+1]) * 0.1;
                    posAttr.array[i*3+2] += (heartAttr.array[i*3+2] - posAttr.array[i*3+2]) * 0.1;
                }
            }
            else if (state === 'PHOTO') {
                rotationAngle += 0.012;
                textParticles.rotation.set(0, rotationAngle * 0.2, 0);
                
                // Kh√≥a xoay c·ªßa photoGroup khi ƒëang ph√≥ng to ƒë·ªÉ ·∫£nh ƒë∆∞·ª£c th·∫≥ng
                photoGroup.rotation.set(0, 0, 0);

                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const r = 8 + Math.sin(i) * 3;
                    const tx = Math.cos(i + rotationAngle) * r;
                    const ty = Math.sin(i * 0.4 + rotationAngle) * (r * 0.5);
                    const tz = -8;
                    posAttr.array[i*3] += (tx - posAttr.array[i*3]) * 0.05;
                    posAttr.array[i*3+1] += (ty - posAttr.array[i*3+1]) * 0.05;
                    posAttr.array[i*3+2] += (tz - posAttr.array[i*3+2]) * 0.05;
                }
            }

            posAttr.needsUpdate = true;

            photoGroup.children.forEach((mesh, i) => {
                if (state === 'PHOTO') {
                    if (i === focusedPhotoIndex) {
                        // Ph√≥ng to tr·ª±c di·ªán v·ªÅ ph√≠a Camera (Z d∆∞∆°ng)
                        // V·ªã tr√≠ (0, 0, 4) gi√∫p ·∫£nh n·∫±m ngay ch√≠nh gi·ªØa m√†n h√¨nh
                        mesh.position.lerp(new THREE.Vector3(0, 0, 4.2), 0.12); 
                        mesh.scale.lerp(new THREE.Vector3(1.8, 1.35, 1), 0.12); 
                        mesh.material.opacity += (1 - mesh.material.opacity) * 0.1;
                        
                        // ƒê·∫∑t g√≥c xoay tuy·ªát ƒë·ªëi v·ªÅ 0 ƒë·ªÉ kh√¥ng b·ªã nh√¨n ch√©o
                        mesh.rotation.x = 0;
                        mesh.rotation.y = 0;
                        mesh.rotation.z = 0;
                        mesh.renderOrder = 100;
                    } else {
                        // C√°c ·∫£nh kh√°c m·ªù ƒëi v√† d·∫°t ra xa
                        const ox = Math.cos(mesh.userData.angle + rotationAngle) * 12;
                        const oy = Math.sin(mesh.userData.angle + rotationAngle) * 8;
                        mesh.position.lerp(new THREE.Vector3(ox, oy, -15), 0.08);
                        mesh.scale.lerp(new THREE.Vector3(0.4, 0.3, 1), 0.08);
                        mesh.material.opacity += (0.05 - mesh.material.opacity) * 0.1;
                        mesh.lookAt(camera.position);
                    }
                } else if (state === 'EXPLODE') {
                    const ox = Math.cos(mesh.userData.angle) * 7;
                    const oy = Math.sin(mesh.userData.angle) * 5;
                    mesh.position.lerp(new THREE.Vector3(ox, oy, 0), 0.05);
                    mesh.scale.lerp(new THREE.Vector3(1.1, 0.8, 1), 0.05);
                    mesh.material.opacity += (0.85 - mesh.material.opacity) * 0.05;
                    mesh.lookAt(camera.position);
                } else {
                    mesh.position.lerp(new THREE.Vector3(0, 0, -30), 0.1);
                    mesh.material.opacity += (0 - mesh.material.opacity) * 0.1;
                }
            });

            renderer.render(scene, camera);
        }

        async function setupMediaPipe() {
            const video = document.getElementById('input_video');
            const statusDiv = document.getElementById('status');
            
            try {
                const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });

                hands.setOptions({ 
                    maxNumHands: 2, 
                    modelComplexity: 1, 
                    minDetectionConfidence: 0.6, 
                    minTrackingConfidence: 0.6 
                });

                hands.onResults((results) => {
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const hCenter = results.multiHandLandmarks[0][9];
                        // Ch·ªâ c·∫≠p nh·∫≠t targetRotation khi kh√¥ng ·ªü ch·∫ø ƒë·ªô PHOTO ƒë·ªÉ tr√°nh rung l·∫Øc
                        if (state !== 'PHOTO') {
                            targetRotationY = (hCenter.x - 0.5) * -2;
                            targetRotationX = (hCenter.y - 0.5) * -1.5;
                        }

                        if (results.multiHandLandmarks.length === 2) {
                            const h1 = results.multiHandLandmarks[0];
                            const h2 = results.multiHandLandmarks[1];
                            const dThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                            const dIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                            
                            if (dThumb < 0.15 && dIndex < 0.15) {
                                state = 'HEART';
                                statusDiv.innerText = "‚ù§Ô∏è K·ª∂ NI·ªÜM NG·ªåT NG√ÄO ‚ù§Ô∏è";
                                statusDiv.style.color = "#ff4d88";
                                return;
                            }
                        }

                        const lm = results.multiHandLandmarks[0];
                        const rawPinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                        smoothedPinchDist = smoothedPinchDist * 0.6 + rawPinch * 0.4;

                        let rawOpen = 0; 
                        [8,12,16,20].forEach(id => rawOpen += Math.hypot(lm[id].x-lm[0].x, lm[id].y-lm[0].y));
                        const currentOpenFactor = rawOpen / 4;
                        smoothedOpenFactor = smoothedOpenFactor * 0.6 + currentOpenFactor * 0.4;

                        if (smoothedOpenFactor < 0.24) { 
                            state = 'TEXT';
                            statusDiv.innerText = "‚úä N·∫Øm tay: Ch·∫ø ƒë·ªô tƒ©nh";
                            statusDiv.style.color = "#fff";
                        } else if (smoothedPinchDist < 0.055) { 
                            if (state !== 'PHOTO') focusedPhotoIndex = Math.floor(Math.random() * PHOTO_COUNT);
                            state = 'PHOTO';
                            statusDiv.innerText = "üëå Ch·∫°m ng√≥n: Ph√≥ng to tr·ª±c di·ªán";
                            statusDiv.style.color = "#00e5ff";
                        } else {
                            state = 'EXPLODE';
                            statusDiv.innerText = "üñê X√≤e tay: ƒêi·ªÅu h∆∞·ªõng 360¬∞";
                            statusDiv.style.color = "#00ffaa";
                        }
                    } else {
                        state = 'TEXT';
                        statusDiv.innerText = "H√£y gi∆° tay tr∆∞·ªõc camera!";
                        statusDiv.style.color = "#fff";
                    }
                });

                const cam = new Camera(video, {
                    onFrame: async () => { await hands.send({image: video}); },
                    width: 640, height: 480 
                });
                
                await cam.start();
            } catch (err) {
                statusDiv.innerText = "L·ªói: Kh√¥ng th·ªÉ m·ªü Camera!";
                statusDiv.style.color = "#ff4444";
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
